# Next Steps

This file provides a high-level overview of the current development focus.

## Current Focus

**NEW TOP PRIORITY: Removing `vscode` Dependencies from Unit Tests**

*   **Problem:** Direct usage of the `vscode` module in unit tests (files in `test/suite/*.test.ts`, excluding `test/suite/e2e/**`) leads to brittle tests that are hard to write and maintain. This is because they become dependent on the complex VS Code API surface, requiring intricate mocking.
*   **Objective:** Refactor unit tests to eliminate direct dependencies on the `vscode` module. This involves introducing abstraction layers (interfaces, wrapper functions) for any VS Code services needed by core logic. Unit tests will then mock these custom abstractions, not `vscode` objects directly. This aligns with the principle outlined in `docs/mistakes.md#1-using-vscode-module-directly-in-unit-tests-for-core-logic`.
*   **Implementation Approach:**
    1.  **Identify `vscode` API Usage:** Systematically review the unit tests within the defined scope to pinpoint all direct interactions with the `vscode` module.
    2.  **Define Abstraction Layers:** For each identified `vscode` service or functionality, create custom interfaces or wrapper functions/classes. These abstractions will define the precise methods and properties required by the core logic, without directly exposing `vscode` types.
    3.  **Implement Concrete Wrappers (Runtime):** Develop concrete implementations of these new abstractions. These implementations will be responsible for interacting with the actual `vscode` module, effectively translating calls from the abstraction layer to the underlying `vscode` API. These wrappers are used when the extension operates within the VS Code environment.
    4.  **Refactor Core Logic:** Modify the core application logic (the code under test) to depend on the newly defined custom abstractions instead of directly calling `vscode` APIs.
    5.  **Mock Abstractions in Unit Tests:** Update the unit tests to mock the custom abstraction layers. Since these abstractions are defined and controlled within the project, creating and managing mocks for them will be significantly simpler and more stable compared to mocking the extensive and potentially internal `vscode` object model.

    *   **Illustrative Example: Abstracting `vscode.LanguageModelChat`**
        *   This ongoing effort (detailed further in the "Abstracting `vscode.LanguageModelChat` for Testability and Flexibility" section) serves as a practical example of this approach.
        *   **Problem Context:** Direct use of `vscode.LanguageModelChat` in `disambiguateEndpoint` caused difficulties in E2E tests, particularly with `instanceof vscode.LanguageModelTextPart` checks.
        *   **Abstraction Steps:**
            1.  **Define `ILanguageModelAdapter`:** An interface specifying a `sendRequest` method that returns promises of simplified, plain JavaScript objects (not `vscode` types).
            2.  **Implement `VscodeLanguageModelAdapter`:** A class implementing `ILanguageModelAdapter`, wrapping a real `vscode.LanguageModelChat`. Its `sendRequest` method calls the actual VS Code API and *transforms* the response objects into the plain JavaScript objects defined by the interface.
            3.  **Refactor `disambiguateEndpoint`:** Modify it to accept an `ILanguageModelAdapter` and work with the plain JavaScript objects.
            4.  **Update E2E Test:** The test provides a test-specific implementation of `ILanguageModelAdapter` that directly yields the plain JavaScript objects, bypassing `instanceof` issues and giving full control over the test data.
*   **Scope:**
    *   `test/suite/call-hierarchy.test.ts`
    *   `test/suite/extension.test.ts`
    *   `test/suite/mermaid-sequence-translator.test.ts`
    *   `test/suite/diagramParticipant.test.ts`
    *   `test/suite/endpoint-disambiguation.test.ts`
*   **Expected Outcome:** Unit tests will be more robust, easier to understand, and faster to run, focusing purely on validating the intended logic in isolation.

---

**(The "Abstracting vscode.LanguageModelChat" section, which is related to this new top priority, will be reviewed and potentially merged or updated as part of this effort. The "Simplifying Generated Sequence Diagrams" task, previously the top priority, will now become a secondary priority.)**

**Simplifying Generated Sequence Diagrams to High-Level Architectural View (Secondary Priority)**

*   **Problem:** The current sequence diagrams generated by the `/restEndpoint` command, which uses VS Code's Call Hierarchy feature, are excessively detailed. For example, a simple endpoint like `TodoItemController.createTodoItem` can produce a diagram with dozens of internal framework calls (e.g., Spring's `ResponseEntity` builder steps, `Assert` calls, `HttpHeaders` manipulations) rather than a concise architectural overview. The recent example for `createTodoItem` (see `docs/example-detailed-sequence-diagram.md` for the full Mermaid output) demonstrates this, resulting in a complex diagram far removed from an expected 3-5 line high-level view.

*   **Objective:** Develop a strategy to transform the detailed call hierarchy data into a more abstract, high-level sequence diagram. The goal is to achieve a representation similar to this conceptual architectural flow:
    1.  HTTP Request -> Controller
    2.  Controller -> Service
    3.  Service -> Repository
    4.  (Repository -> Database - often implicit)
    5.  Controller -> HTTP Response

*   **Plan (Initial Thoughts):**
    1.  **Analyze Call Hierarchy Data:** *(Substantially completed for initial rule definition)*
        *   Investigate the structure of the `CustomHierarchyNode` tree provided by VS Code's call hierarchy feature. *(Completed)*
        *   Identify patterns and characteristics of "significant" architectural interactions (e.g., calls between major components like Controller, Service, Repository) versus internal or low-level framework calls (e.g., utility functions, getters/setters, framework-specific boilerplate). *(Initial patterns identified through E2E test data capture)*
            *   Successfully captured `CustomHierarchyNode` data for various scenarios: no outgoing calls, intra-class calls (`TestController.complexHello` -> `privateHelperHello`), inter-class calls (`TestController.fullComplexHello` -> `TestService.getServiceData`), and external JDK library calls with internal depth (`TestService.getListSize` -> `java.util.ArrayList` methods like `ArrayList()`, `add()`, `size()`, and internal `grow()`).
            *   Confirmed `item.uri.path` as the primary field to distinguish local project calls (e.g., within `test/fixtures/java-spring-test-project`) from external library/JDK calls (e.g., `/Library/Java/.../java/util/ArrayList.java`).
        *   Consider properties such as call depth, source/target module/package names (e.g., `org.springframework.*` vs. project-specific packages), and frequency of certain call types. *(Initial observations made; deeper analysis on frequency/common patterns will be part of heuristic refinement).*
    2.  **Define Abstraction Rules/Heuristics:** *(Next immediate priority)* Develop a robust set of rules or heuristics to filter, group, or abstract calls from the call hierarchy data. This will primarily involve:
        *   **Rule 1: Identify Local vs. External Calls:**
            *   **Input:** `CustomHierarchyNode.item.uri.path` (path to the code file) and `vscode.workspace.workspaceFolders` (project root folder(s)).
            *   **Logic:** Determine if a node's URI path is within any of the `workspaceFolders` (or a more specific, configurable list of project source directories). This distinguishes project-specific "local" code from "external" code (e.g., JDK, libraries).
            *   **Output:** Classification of each call hierarchy node as "local" or "external".
        *   **Rule 2: Prioritize Direct Local Project Calls:**
            *   Local-to-local calls (e.g., `Controller` -> `Service`, `Service` -> `Repository`, or a `Controller` -> `private helper` in the same class) should generally be included in the abstracted diagram, at least at the first level of calls originating from another local component.
        *   **Rule 3: Aggressively Filter/Abstract External Calls:**
            *   **Default Behavior (MVP):** For a call from local code to an external method (e.g., to `java.util.ArrayList.size()` or a Spring internal), the diagram should not show the external call itself or any of its children. The call effectively "terminates" at this local-to-external boundary for diagram purposes. Complete filtering of external calls and their children is simpler for MVP.
            *   **Future Enhancement (Abstraction):** Instead of complete filtering, consider replacing a sequence of calls *to* and *within* a well-known external library/framework with a single representative node (e.g., an interaction box labeled "java.util" or "Spring Framework").
            *   The path analysis from step 1 (identifying patterns for `java.util.*`, `org.springframework.*`, `node_modules`, etc.) will be crucial input for this rule.
        *   **Rule 4: Collapse Sequential Calls within the Same Local Component (Optional for MVP):**
            *   If a local method A makes multiple calls to other private/internal methods (B, C, D) within the *same class or immediate local module*, and B, C, D do not call out to other major architectural components, consider if these internal calls should be collapsed, or if only the call to A (from an external caller) is architecturally significant. For MVP, showing all direct local calls might be acceptable.
            *   Defining "same logical component" and "significant architectural insight" will need careful consideration (e.g., based on class boundaries, package structure, or specific annotations).
        *   **Rule 5: Handling Call Depth (Primarily for External Calls):**
            *   If external calls are not completely filtered (e.g., if showing the first external call but not its children), apply a strict maximum depth for traversing into any external call chain (e.g., depth 0 or 1 relative to the *first* call that crossed the local-to-external boundary).
            *   The current `MAX_CALL_HIERARCHY_DEPTH` (e.g., 5) in `call-hierarchy.ts` is for the raw tree; this abstraction layer will apply its own, much stricter depth limits for external branches.
        *   **(Future Consideration)** Allow user configuration for "always include" or "always exclude" packages/modules, or to set a maximum depth for displaying external calls.
    3.  **Modify Diagram Generation Logic:** *(Following Rule Definition)*
        *   Update the existing `generateMermaidSequenceDiagram` function, or preferably, introduce a new abstraction layer (e.g., a `CallHierarchyProcessor` or `DiagramAbstractor` class/module).
        *   This new layer would take the raw `CustomHierarchyNode` tree as input, apply the defined abstraction rules and heuristics, and produce a *filtered/abstracted* tree or an intermediate representation.
        *   The `generateMermaidSequenceDiagram` function would then consume this processed representation to generate the Mermaid syntax. This separation of concerns (processing vs. rendering) will improve maintainability.
    4.  **Iterative Refinement and Testing:**
        *   Test rigorously with various endpoints, project types (e.g., Java Spring Boot, Node.js Express, Python Django/Flask), and common frameworks to ensure the abstraction is effective and produces meaningful, easy-to-understand high-level diagrams.
        *   Establish clear metrics for "effectiveness" and "meaningfulness," possibly including diagram complexity (node/edge count reduction), task completion time for understanding an endpoint, and qualitative user feedback.
    5.  **User Control (Future Iteration):**
        *   Consider providing users with clear and simple options to toggle between the new abstracted/high-level view and the original detailed/raw view.
        *   This could be implemented as a command option, a setting in `settings.json`, or a UI control within the webview displaying the diagram.

*   **Expected Outcome:** The `/restEndpoint` command will be able to produce sequence diagrams that offer a clear, high-level architectural understanding of an endpoint's interactions, making it more intuitive and useful for common use cases. The detailed view might still be available as an advanced option.

---
*(The "Abstracting vscode.LanguageModelChat" section, previously the top priority, will now become a secondary priority. The existing "Call Hierarchy MVP (Secondary Priority)" content will follow and may need to be re-prioritized or integrated accordingly.)*

**Abstracting `vscode.LanguageModelChat` for Testability and Flexibility (Related to Top Priority / To Be Reviewed)**

*   **Problem:** The direct usage of `vscode.LanguageModelChat` (and its associated types like `vscode.LanguageModelTextPart`) within `disambiguateEndpoint` has led to significant challenges in E2E testing. Specifically, mocking the `lm.sendRequest` method to return objects that satisfy strict `instanceof vscode.LanguageModelTextPart` checks performed by `disambiguateEndpoint` has proven difficult, as the test environment cannot easily create "real" instances of these potentially internal VS Code API classes. This has been a major blocker for the `test/suite/e2e/mermaid-real-callhierarchy.e2e.test.ts` test.

*   **Objective:** Decouple `disambiguateEndpoint` from the concrete `vscode.LanguageModelChat` implementation by introducing an abstraction layer (an adapter or wrapper class). This will allow for:
    1.  Easier and more reliable mocking in E2E tests, as we can provide a test-specific implementation of the adapter that returns plain, well-defined JavaScript objects, bypassing `instanceof` issues.
    2.  Improved observability into the data structures being passed to and from the LLM, by enabling detailed logging within the adapter.
    3.  Potential flexibility in the future to swap out LLM providers or modify request/response handling without altering the core logic of `disambiguateEndpoint`.

*   **Plan:**
    1.  **Define an Adapter Interface:**
        *   Create a new TypeScript interface (e.g., `ILanguageModelAdapter`) that defines the necessary methods for interacting with an LLM, primarily a `sendRequest` method.
        *   The `sendRequest` method in this interface should be defined to return promises of simplified, plain JavaScript objects that represent the LLM's response structure (e.g., `{ stream: AsyncIterable<{ type: 'text'; value: string } | { type: 'functionCall'; details: any }>} ` or similar, avoiding direct VS Code API types in its return signature if possible for maximum testability).

    2.  **Implement a `VscodeLanguageModelAdapter`:**
        *   Create a concrete class `VscodeLanguageModelAdapter` that implements `ILanguageModelAdapter`.
        *   This class will wrap an actual `vscode.LanguageModelChat` instance.
        *   Its `sendRequest` method will call the underlying `vscode.LanguageModelChat.sendRequest`, receive the real VS Code API objects (like `LanguageModelTextPart`), and then *transform* these objects into the plain JavaScript objects defined by our `ILanguageModelAdapter`'s return type. This transformation step is crucial.
        *   **Verbose Logging:** Implement detailed logging within this adapter to capture the structure of the *actual* objects received from `vscode.LanguageModelChat.sendRequest` (before transformation) and the structure of the objects it returns (after transformation). This will provide the necessary insights for debugging and understanding the real VS Code types.

    3.  **Refactor `disambiguateEndpoint`:**
        *   Modify `disambiguateEndpoint` to accept an instance of `ILanguageModelAdapter` instead of a direct `vscode.LanguageModelChat` instance.
        *   Update the stream processing logic within `disambiguateEndpoint` to work with the plain JavaScript objects returned by the adapter's `sendRequest` method. This means removing the `instanceof vscode.LanguageModelTextPart` check and instead relying on a property like `type === 'text'` on the received stream objects to access the `value`.

    4.  **Update E2E Test (`mermaid-real-callhierarchy.e2e.test.ts`):**
        *   In the test setup, instead of mocking `vscode.lm.selectChatModels` to resolve to a `vscode.LanguageModelChat` mock, create a *test-specific implementation* of `ILanguageModelAdapter`.
        *   This test adapter's `sendRequest` method will be much simpler:
            *   It will still perform the line-by-line parsing of the prompt to determine the chosen index.
            *   It will then directly construct and yield the plain JavaScript objects (e.g., `{ type: 'text', value: '8' }`) that the refactored `disambiguateEndpoint` now expects from the adapter.
        *   This completely bypasses the `instanceof` issue and gives us full control over the data `disambiguateEndpoint` receives from its LLM interaction point.

    5.  **Iterative Debugging with Manual Log Analysis:**
        *   During the implementation of `VscodeLanguageModelAdapter`, logs of the real structures from `vscode.LanguageModelChat.sendRequest` will be manually provided.
        *   These logs will be used to refine the transformation logic in `VscodeLanguageModelAdapter` and to ensure the plain JavaScript objects accurately represent the necessary information.
        *   This will also inform the design of the simplified objects that the test adapter and the refactored `disambiguateEndpoint` will use.

    6.  **Update `docs/mistakes.md` (If Applicable):** If this abstraction strategy significantly improves testability around `instanceof` issues with external APIs, consider adding a point about it.

*   **Expected Outcome:** The `test/suite/e2e/mermaid-real-callhierarchy.e2e.test.ts` should pass reliably. `disambiguateEndpoint` will be more robustly testable and less coupled to the specifics of `vscode.LanguageModelChat`'s returned object instances.

## Call Hierarchy MVP (Secondary Priority)

The primary focus has shifted to implementing the **Call Hierarchy** feature for `/restEndpoint`. We are taking an MVP (Minimum Viable Product) approach to get this working end-to-end.

*   **Previous Task (Endpoint Disambiguation):** Initial implementation for endpoint disambiguation (including heuristic checks and basic LLM integration) is complete. Further enhancements and advanced scenarios will be revisited after the MVP for call hierarchy is established. The immediate next step for disambiguation is to refactor the fallback mechanism to use chat-based clarification instead of `showQuickPick`.
*   **Current Top Priority:** Design and implement the call hierarchy determination for a selected endpoint. This is the core of the Call Hierarchy MVP.
    *   **(Completed)** Integrate the existing `buildCallHierarchyTree` function (from `src/call-hierarchy.ts`) into the `/restEndpoint` command handler.
    *   Implement logic to translate the `CustomHierarchyNode` tree structure (from `buildCallHierarchyTree`) into a Mermaid sequence diagram format.
    *   Display the generated Mermaid diagram to the user within the webview (likely using the existing `createAndShowDiagramWebview` mechanism).
    *   **Manual Testing & Observation:** Run the `/restEndpoint` command with a Java Spring Boot project to observe the generated sequence diagram. Note issues with participant names, call flow, and overall clarity.
    *   **Refinement (based on testing):** Refine `getParticipantName`, consider adding `activate`/`deactivate` logic, and address any issues in `sanitizeParticipantName` or `escapeMermaidMessage` in `src/mermaid-sequence-translator.ts`.
    *   Add dedicated unit tests for `src/call-hierarchy.ts` (mocking `vscode.commands.executeCommand`).
    *   Add unit tests for the Mermaid diagram translation logic (`src/mermaid-sequence-translator.ts`).
    *   **Advance E2E Testing for Call Hierarchy (`/restEndpoint`):**
        *   **(Completed)** Modified `test/suite/e2e/mermaid-real-callhierarchy.e2e.test.ts` to use the real `discoverEndpoints` function and real call hierarchy LSP, significantly increasing test coverage of the actual endpoint identification and diagramming pipeline. The `disambiguateEndpoint` function remains stubbed in this test to ensure the target endpoint (e.g., `sayHello()`) is selected correctly after real discovery.
        *   **Next: Unmock `disambiguateEndpoint` in E2E Tests:** The subsequent step for `test/suite/e2e/mermaid-real-callhierarchy.e2e.test.ts` is to unmock the `disambiguateEndpoint` function. This will be revisited *after* the `ILanguageModelAdapter` refactoring is complete. The adapter strategy should make this step much more straightforward.
            *   **Mitigating LLM Flakiness (Post-Adapter):** Once the adapter is in place, if the real `VscodeLanguageModelAdapter` is used in some E2E tests:
                *   **Robust Prompt Engineering:** Design highly specific and unambiguous prompts for the test scenarios.
                *   **Retry Mechanism:** Implement a retry loop within the E2E test.
                *   **Statistical Reliability:** This retry approach significantly enhances test stability.
                *   **Outcome Logging:** Each attempt's outcome will be logged.
*   **Detailed Status & Plan:** See `docs/rest_endpoint_feature.md` (this document is also being updated to reflect the current priorities and progress).

## Guiding Principles

Please refer to `docs/development_principles.md` for important guidelines, especially regarding unit testing.

## Recently Completed Tasks

See `docs/completed_major_tasks.md` for a list of recently finished items.

## Anti-Patterns

See `docs/mistakes.md` for patterns to avoid.