# Next Steps

This file provides a high-level overview of the current development focus.

## Current Focus

**NEW TOP PRIORITY: Simplifying Generated Sequence Diagrams to High-Level Architectural View**

*   **Problem:** The current sequence diagrams generated by the `/restEndpoint` command, which uses VS Code's Call Hierarchy feature, are excessively detailed. For example, a simple endpoint like `TodoItemController.createTodoItem` can produce a diagram with dozens of internal framework calls (e.g., Spring's `ResponseEntity` builder steps, `Assert` calls, `HttpHeaders` manipulations) rather than a concise architectural overview. The recent example for `createTodoItem` (see `docs/example-detailed-sequence-diagram.md` for the full Mermaid output) demonstrates this, resulting in a complex diagram far removed from an expected 3-5 line high-level view.

*   **Objective:** Develop a strategy to transform the detailed call hierarchy data into a more abstract, high-level sequence diagram. The goal is to achieve a representation similar to this conceptual architectural flow:
    1.  HTTP Request -> Controller
    2.  Controller -> Service
    3.  Service -> Repository
    4.  (Repository -> Database - often implicit)
    5.  Controller -> HTTP Response

*   **Plan (Initial Thoughts):**
    1.  **Analyze Call Hierarchy Data:** *(Substantially completed for initial rule definition)*
        *   Investigate the structure of the `CustomHierarchyNode` tree provided by VS Code's call hierarchy feature. *(Completed)*
        *   Identify patterns and characteristics of "significant" architectural interactions (e.g., calls between major components like Controller, Service, Repository) versus internal or low-level framework calls (e.g., utility functions, getters/setters, framework-specific boilerplate). *(Initial patterns identified through E2E test data capture)*
            *   Successfully captured `CustomHierarchyNode` data for various scenarios: no outgoing calls, intra-class calls (`TestController.complexHello` -> `privateHelperHello`), inter-class calls (`TestController.fullComplexHello` -> `TestService.getServiceData`), and external JDK library calls with internal depth (`TestService.getListSize` -> `java.util.ArrayList` methods like `ArrayList()`, `add()`, `size()`, and internal `grow()`).
            *   Confirmed `item.uri.path` as the primary field to distinguish local project calls (e.g., within `test/fixtures/java-spring-test-project`) from external library/JDK calls (e.g., `/Library/Java/.../java/util/ArrayList.java`).
        *   Consider properties such as call depth, source/target module/package names (e.g., `org.springframework.*` vs. project-specific packages), and frequency of certain call types. *(Initial observations made; deeper analysis on frequency/common patterns will be part of heuristic refinement).*
    2.  **Define Abstraction Rules/Heuristics:** *(Next immediate priority)* Develop a robust set of rules or heuristics to filter, group, or abstract calls. This will primarily involve:
        *   **Rule 1: Identify Local vs. External Calls:**
            *   Input: `CustomHierarchyNode.item.uri.path`, `vscode.workspace.workspaceFolders`.
            *   Logic: Determine if a node's URI path is within any of the `workspaceFolders` (or a more specific, configurable list of project source directories).
            *   Output: Classification of each node as "local" or "external".
        *   **Rule 2: Prioritize Direct Local Project Calls:**
            *   Local-to-local calls (e.g., `Controller` -> `Service`, `Service` -> `Repository`, `Controller` -> `private helper` in same class) should generally be included in the abstracted diagram, at least at the first level of calls from another local component.
        *   **Rule 3: Aggressively Filter/Abstract External Calls:**
            *   **Default Behavior:** For an external call (e.g., to `java.util.ArrayList.size()` or a Spring internal), do not show the external call itself or any of its children in the diagram. The call from a local method to the first external method essentially "terminates" at that boundary for diagram purposes.
            *   **Future Enhancement (Abstraction):** Instead of complete filtering, consider replacing a sequence of calls *to* and *within* a well-known external library/framework with a single representative node (e.g., an interaction box labeled "java.util" or "Spring Framework"). For MVP, complete filtering of external calls is simpler.
            *   The path analysis from step 1 (e.g., identifying `java.util.*`, `org.springframework.*`, `node_modules`) will feed into this.
        *   **Rule 4: Collapse Sequential Calls within the Same Local Component (Optional for MVP):**
            *   If a local method A makes multiple calls to other private methods (B, C, D) within the *same class or immediate local module*, and B, C, D do not call out to other major components, consider if these should be collapsed or if only the call from A is architecturally significant. For MVP, showing all direct local calls might be acceptable.
            *   The definition of "same logical component" and "significant architectural insight" will need careful consideration (e.g., based on class boundaries, package structure, or specific annotations).
        *   **Rule 5: Handling Call Depth (primarily for external calls):**
            *   If external calls are not completely filtered (e.g., if we opt for showing the first external call but not its children), apply a strict maximum depth for traversing into any external call chain (e.g., depth 0 or 1 relative to the first external call). Our current `MAX_CALL_HIERARCHY_DEPTH` (e.g., 5) in `call-hierarchy.ts` is for the raw tree; the abstraction layer will apply its own, much stricter depth limits for external branches.
        *   **(Future Consideration)** Allow user configuration for "always include" or "always exclude" packages/modules, or to set a maximum depth for external calls.
    3.  **Modify Diagram Generation Logic:** *(Following Rule Definition)*
        *   Update the existing `generateMermaidSequenceDiagram` function, or preferably, introduce a new abstraction layer (e.g., a `CallHierarchyProcessor` or `DiagramAbstractor` class/module).
        *   This new layer would take the raw `CustomHierarchyNode` tree as input, apply the defined abstraction rules and heuristics, and produce a *filtered/abstracted* tree or an intermediate representation.
        *   The `generateMermaidSequenceDiagram` function would then consume this processed representation to generate the Mermaid syntax. This separation of concerns (processing vs. rendering) will improve maintainability.
    4.  **Iterative Refinement and Testing:**
        *   Test rigorously with various endpoints, project types (e.g., Java Spring Boot, Node.js Express, Python Django/Flask), and common frameworks to ensure the abstraction is effective and produces meaningful, easy-to-understand high-level diagrams.
        *   Establish clear metrics for "effectiveness" and "meaningfulness," possibly including diagram complexity (node/edge count reduction), task completion time for understanding an endpoint, and qualitative user feedback.
    5.  **User Control (Future Iteration):**
        *   Consider providing users with clear and simple options to toggle between the new abstracted/high-level view and the original detailed/raw view.
        *   This could be implemented as a command option, a setting in `settings.json`, or a UI control within the webview displaying the diagram.

*   **Expected Outcome:** The `/restEndpoint` command will be able to produce sequence diagrams that offer a clear, high-level architectural understanding of an endpoint's interactions, making it more intuitive and useful for common use cases. The detailed view might still be available as an advanced option.

---
*(The "Abstracting vscode.LanguageModelChat" section, previously the top priority, will now become a secondary priority. The existing "Call Hierarchy MVP (Secondary Priority)" content will follow and may need to be re-prioritized or integrated accordingly.)*

**Abstracting `vscode.LanguageModelChat` for Testability and Flexibility (Secondary Priority)**

*   **Problem:** The direct usage of `vscode.LanguageModelChat` (and its associated types like `vscode.LanguageModelTextPart`) within `disambiguateEndpoint` has led to significant challenges in E2E testing. Specifically, mocking the `lm.sendRequest` method to return objects that satisfy strict `instanceof vscode.LanguageModelTextPart` checks performed by `disambiguateEndpoint` has proven difficult, as the test environment cannot easily create "real" instances of these potentially internal VS Code API classes. This has been a major blocker for the `test/suite/e2e/mermaid-real-callhierarchy.e2e.test.ts` test.

*   **Objective:** Decouple `disambiguateEndpoint` from the concrete `vscode.LanguageModelChat` implementation by introducing an abstraction layer (an adapter or wrapper class). This will allow for:
    1.  Easier and more reliable mocking in E2E tests, as we can provide a test-specific implementation of the adapter that returns plain, well-defined JavaScript objects, bypassing `instanceof` issues.
    2.  Improved observability into the data structures being passed to and from the LLM, by enabling detailed logging within the adapter.
    3.  Potential flexibility in the future to swap out LLM providers or modify request/response handling without altering the core logic of `disambiguateEndpoint`.

*   **Plan:**
    1.  **Define an Adapter Interface:**
        *   Create a new TypeScript interface (e.g., `ILanguageModelAdapter`) that defines the necessary methods for interacting with an LLM, primarily a `sendRequest` method.
        *   The `sendRequest` method in this interface should be defined to return promises of simplified, plain JavaScript objects that represent the LLM's response structure (e.g., `{ stream: AsyncIterable<{ type: 'text'; value: string } | { type: 'functionCall'; details: any }>} ` or similar, avoiding direct VS Code API types in its return signature if possible for maximum testability).

    2.  **Implement a `VscodeLanguageModelAdapter`:**
        *   Create a concrete class `VscodeLanguageModelAdapter` that implements `ILanguageModelAdapter`.
        *   This class will wrap an actual `vscode.LanguageModelChat` instance.
        *   Its `sendRequest` method will call the underlying `vscode.LanguageModelChat.sendRequest`, receive the real VS Code API objects (like `LanguageModelTextPart`), and then *transform* these objects into the plain JavaScript objects defined by our `ILanguageModelAdapter`'s return type. This transformation step is crucial.
        *   **Verbose Logging:** Implement detailed logging within this adapter to capture the structure of the *actual* objects received from `vscode.LanguageModelChat.sendRequest` (before transformation) and the structure of the objects it returns (after transformation). This will provide the necessary insights for debugging and understanding the real VS Code types.

    3.  **Refactor `disambiguateEndpoint`:**
        *   Modify `disambiguateEndpoint` to accept an instance of `ILanguageModelAdapter` instead of a direct `vscode.LanguageModelChat` instance.
        *   Update the stream processing logic within `disambiguateEndpoint` to work with the plain JavaScript objects returned by the adapter's `sendRequest` method. This means removing the `instanceof vscode.LanguageModelTextPart` check and instead relying on a property like `type === 'text'` on the received stream objects to access the `value`.

    4.  **Update E2E Test (`mermaid-real-callhierarchy.e2e.test.ts`):**
        *   In the test setup, instead of mocking `vscode.lm.selectChatModels` to resolve to a `vscode.LanguageModelChat` mock, create a *test-specific implementation* of `ILanguageModelAdapter`.
        *   This test adapter's `sendRequest` method will be much simpler:
            *   It will still perform the line-by-line parsing of the prompt to determine the chosen index.
            *   It will then directly construct and yield the plain JavaScript objects (e.g., `{ type: 'text', value: '8' }`) that the refactored `disambiguateEndpoint` now expects from the adapter.
        *   This completely bypasses the `instanceof` issue and gives us full control over the data `disambiguateEndpoint` receives from its LLM interaction point.

    5.  **Iterative Debugging with Manual Log Analysis:**
        *   During the implementation of `VscodeLanguageModelAdapter`, logs of the real structures from `vscode.LanguageModelChat.sendRequest` will be manually provided.
        *   These logs will be used to refine the transformation logic in `VscodeLanguageModelAdapter` and to ensure the plain JavaScript objects accurately represent the necessary information.
        *   This will also inform the design of the simplified objects that the test adapter and the refactored `disambiguateEndpoint` will use.

    6.  **Update `docs/mistakes.md` (If Applicable):** If this abstraction strategy significantly improves testability around `instanceof` issues with external APIs, consider adding a point about it.

*   **Expected Outcome:** The `test/suite/e2e/mermaid-real-callhierarchy.e2e.test.ts` should pass reliably. `disambiguateEndpoint` will be more robustly testable and less coupled to the specifics of `vscode.LanguageModelChat`'s returned object instances.

## Call Hierarchy MVP (Secondary Priority)

The primary focus has shifted to implementing the **Call Hierarchy** feature for `/restEndpoint`. We are taking an MVP (Minimum Viable Product) approach to get this working end-to-end.

*   **Previous Task (Endpoint Disambiguation):** Initial implementation for endpoint disambiguation (including heuristic checks and basic LLM integration) is complete. Further enhancements and advanced scenarios will be revisited after the MVP for call hierarchy is established. The immediate next step for disambiguation is to refactor the fallback mechanism to use chat-based clarification instead of `showQuickPick`.
*   **Current Top Priority:** Design and implement the call hierarchy determination for a selected endpoint. This is the core of the Call Hierarchy MVP.
    *   **(Completed)** Integrate the existing `buildCallHierarchyTree` function (from `src/call-hierarchy.ts`) into the `/restEndpoint` command handler.
    *   Implement logic to translate the `CustomHierarchyNode` tree structure (from `buildCallHierarchyTree`) into a Mermaid sequence diagram format.
    *   Display the generated Mermaid diagram to the user within the webview (likely using the existing `createAndShowDiagramWebview` mechanism).
    *   **Manual Testing & Observation:** Run the `/restEndpoint` command with a Java Spring Boot project to observe the generated sequence diagram. Note issues with participant names, call flow, and overall clarity.
    *   **Refinement (based on testing):** Refine `getParticipantName`, consider adding `activate`/`deactivate` logic, and address any issues in `sanitizeParticipantName` or `escapeMermaidMessage` in `src/mermaid-sequence-translator.ts`.
    *   Add dedicated unit tests for `src/call-hierarchy.ts` (mocking `vscode.commands.executeCommand`).
    *   Add unit tests for the Mermaid diagram translation logic (`src/mermaid-sequence-translator.ts`).
    *   **Advance E2E Testing for Call Hierarchy (`/restEndpoint`):**
        *   **(Completed)** Modified `test/suite/e2e/mermaid-real-callhierarchy.e2e.test.ts` to use the real `discoverEndpoints` function and real call hierarchy LSP, significantly increasing test coverage of the actual endpoint identification and diagramming pipeline. The `disambiguateEndpoint` function remains stubbed in this test to ensure the target endpoint (e.g., `sayHello()`) is selected correctly after real discovery.
        *   **Next: Unmock `disambiguateEndpoint` in E2E Tests:** The subsequent step for `test/suite/e2e/mermaid-real-callhierarchy.e2e.test.ts` is to unmock the `disambiguateEndpoint` function. This will be revisited *after* the `ILanguageModelAdapter` refactoring is complete. The adapter strategy should make this step much more straightforward.
            *   **Mitigating LLM Flakiness (Post-Adapter):** Once the adapter is in place, if the real `VscodeLanguageModelAdapter` is used in some E2E tests:
                *   **Robust Prompt Engineering:** Design highly specific and unambiguous prompts for the test scenarios.
                *   **Retry Mechanism:** Implement a retry loop within the E2E test.
                *   **Statistical Reliability:** This retry approach significantly enhances test stability.
                *   **Outcome Logging:** Each attempt's outcome will be logged.
*   **Detailed Status & Plan:** See `docs/rest_endpoint_feature.md` (this document is also being updated to reflect the current priorities and progress).

## Guiding Principles

Please refer to `docs/development_principles.md` for important guidelines, especially regarding unit testing.

## Recently Completed Tasks

See `docs/completed_major_tasks.md` for a list of recently finished items.

## Anti-Patterns

See `docs/mistakes.md` for patterns to avoid.